################################################################################
# Ini-File for jnicc
################################################################################

# Log directory:
# LogDir = /home/me/tmp

#------------------------------------------------------------------------------#
# If a MPS file name is specified, the model is read from file, else the model
# will be generated by the integrated model generator with the defined model
# parameters Q, N, R and S
 
# Mps File:
#MpsFile = sample.mps

# Number of symbols in alphabet:
Q = 7

# Codeword length:
N = 10

# Radius:
R = 2

# Decomposition factor (2^S). Max. 23:
S = 2

# Bound type. 0: RHS (q**(n-s)), 
#             1: 1, 
#             2: PL (0 <= Uj < +INF), 
#             3: BV (variable is binary (equal 0 or 1))
BTyp = 0

# Lower bound cost vector. Default is -INF
#LBZ = 0

# Upper bound cost vector. Default is +INF
#UBZ = 120

# Row type. 0: E, 1: G
RTyp = 1

#-------------------------  Cuts  ---------------------------------------------#
# Call syntax: <Cut> <howOften>
# howOften affects how generator is used. 
#   0 or 1 means always, > 1 means every that number of nodes.
#   Negative values have same meaning as positive but they may be switched 
#   off (-> -100) by code if not many cuts generated at continuous.
#   -99 is just done at root.
# Parameter CutGomory: <howOften> <limit>
CutGomory       -1 50

#CutRedSplit     -1
#CutTwomir       -1
#CutMixIntRound  -1
#CutMixIntRound2 -1
#CutProbing      -1
#CutKnapsack     -1

#------------------  Best solution so far  -----------------------------------#
# q6_n9_R3_s2 (890):
#SOL =  x0=29  x1=24  x2=24  x3=24  x4=24  x5=24  x6=24  x7=25  x8=25  x9=25 x10=25 x11=24 x12=24 x13=24 x14=24 x15=24 \
      x16=24 x17=29 x18=24 x19=25 x20=25 x21=25 x22=25 x23=24 x24=24 x25=25 x26=25 x27=25 x28=25 x29=24 x30=24 x31=25 \
      x32=25 x33=25 x34=25 x35=24 

# q2_n10_R1_s8 (107):
#SOL = \
  x0=1   x3=1   x5=1  x10=1  x12=1  x15=1  x16=1  x18=1  x20=1  x23=1  x25=2  x30=1  x33=1  x38=2  x40=1  x42=1 \
 x43=1  x45=1  x48=1  x51=1  x53=1  x55=1  x58=1  x60=1  x63=1  x67=1  x69=1  x70=1  x73=1  x74=1  x76=1  x80=1 \
 x81=1  x86=1  x88=1  x91=1  x93=1  x95=1  x96=1  x98=1 x100=1 x103=1 x105=1 x110=1 x111=1 x115=1 x117=1 x118=1 \
x121=1 x122=1 x124=1 x131=1 x132=1 x133=1 x134=1 x136=1 x137=1 x143=1 x145=1 x146=1 x149=1 x152=1 x155=1 x157=1 \
x158=1 x161=1 x162=1 x164=1 x167=1 x170=1 x173=1 x174=1 x176=1 x182=1 x183=1 x185=1 x187=1 x188=1 x192=1 x195=1 \
x197=1 x202=1 x204=1 x207=1 x208=1 x210=1 x212=1 x215=1 x217=1 x221=1 x222=1 x223=1 x225=1 x230=2 x232=1 x233=1 \
x235=1 x237=1 x240=1 x243=1 x245=1 x250=1 x252=1 x255=1

#------------------------------------------------------------------------------#
# Cbc Log Level:
CbcLogLevel = 0

# Optimization direction:
MinOrMax = MIN

# Number of threads
Threads = 4

# Number of nodes for initiale search (in 1000):
CmpNodesDepth = 100

# Max nodes in tree (in 1000):
MaxNodesOnTree = 1000

#------------------------------------------------------------------------------#
# Libs used:
CoinLibs = WrapCoin

